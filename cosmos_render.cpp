/*

### cosmos_render

To compile, use the command

```bash
clang++ cosmos_render.cpp -o cosmos_render -std=c++11 -lOpenCL
```

To run, use the command

```bash
./cosmos_render <frames> [bodies=24576]
```

This will cause cosmos_render to output a bunch of rendered frames to the
directory that it was started in. These rendered frames will be image files,
produced by rendering the corresponding simulation frames generated by running
cosmos_simulate.

## Even more speed

To speed up simulations and renders even more, compile with

```bash
clang++ cosmos_tool.cpp -o cosmos_tool -std=c++11 -lOpenCL -Ofast -march=native
```

*/

#include <iostream>
#include <sstream>
#include <fstream>

#include <ctime>

#include <memory>

// Include stb_image_write.

#define STB_IMAGE_WRITE_IMPLEMENTATION

#include "stb_image_write.h"

// Include OpenCL.

#ifdef __APPLE__

#define CL_SILENCE_DEPRECATION

#include <OpenCL/OpenCL.h>

#else

#include <CL/cl.h>

#endif

// Include the kernel source.

#define __stringify(source) #source

const char* kernel_source =

#include "cosmos_render.cl"

#undef __stringify

size_t kernel_source_size = strlen(kernel_source);

// Include the thermal colormap.

#define THERMAL_OPEN_CL

#include "thermal_colormap.h"

// Write a message to std::cout.

void say(std::string message)
{
	std::cout << message << std::endl;
}

// Entry point.

int main(int argc, char** argv)
{
	// Parse command line arguments.

	if (argc != 2)
	{
		std::cout << "Usage: " << argv[0] << " <frames> [bodies=24576]" << std::endl;

		return EXIT_FAILURE;
	}

	int frames = atoi(argv[1]);

	int n = 24576;

	if (argc == 3)
	{
		n = atoi(argv[2]);
	}

	// Create variables to hold return codes.

	cl_int r_code;

	cl_int r_code1;
	cl_int r_code2;

	// Create identifier objects to hold information about the available
	// platforms and available devices.

	cl_platform_id platform_id = NULL;

	cl_device_id device_id = NULL;

	// Create unsigned integer objects to hold the amount of available
	// platforms and available devices.

	cl_uint num_platforms;

	cl_uint num_devices;

	// Get the first available platform and store the amount of available
	// platforms.

	clGetPlatformIDs(1, &platform_id, &num_platforms);

	// Get the first available device on the first available platform. Store
	// the amount of available devices. This device will be referred to as the
	// 'default device'.

	clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &device_id, &num_devices);

	// Create an OpenCL context on the default device.

	cl_context context = clCreateContext(0, 1, &device_id, NULL, NULL, &r_code);

	// Make sure the OpenCL context was created successfully.

	if (r_code != CL_SUCCESS)
	{
		say("Could not create an OpenCL context.");

		return EXIT_FAILURE;
	}

	// Create an OpenCL command queue.

	cl_command_queue command_queue = clCreateCommandQueue(context, device_id, 0, &r_code);

	// Make sure the OpenCL command queue was created successfully.

	if (r_code != CL_SUCCESS)
	{
		say("Could not create an OpenCL command queue.");

		return EXIT_FAILURE;
	}

	// Allocate a buffer to hold the frame body data, CPU side.

	cl_float4* cpu_bodies = (cl_float4*)malloc(n * sizeof(cl_float4));

	// Allocate a buffer to hold the frame body data, GPU side.

	cl_mem gpu_bodies = clCreateBuffer(context, CL_MEM_READ_WRITE, n * sizeof(cl_float4), NULL, &r_code);

	if (r_code != CL_SUCCESS)
	{
		say("Could not allocate GPU memory.");

		return EXIT_FAILURE;
	}

	// PARAM: The dimensions of the image (which is square).

	int res = 800;

	int stride_in_bytes = res * 4;

	// Allocate a buffer to hold the rendered frame, CPU side.

	unsigned char* cpu_img = (unsigned char*)malloc(res * res * 4 * sizeof(unsigned char));

	// Allocate a buffer to hold the rendered frame, GPU side.

	cl_mem gpu_img = clCreateBuffer(context, CL_MEM_READ_WRITE, res * res * sizeof(cl_uint), NULL, &r_code);

	if (r_code != CL_SUCCESS)
	{
		say("Could not allocate GPU memory.");

		return EXIT_FAILURE;
	}

	// Allocate an array to hold the thermal colormap, GPU side.

	cl_mem gpu_colormap = clCreateBuffer(context, CL_MEM_READ_WRITE, 256 * sizeof(cl_uint), NULL, &r_code);

	if (r_code != CL_SUCCESS)
	{
		say("Could not allocate GPU memory.");

		return EXIT_FAILURE;
	}

	// Copy the thermal colormap from the CPU to the GPU.

	r_code = clEnqueueWriteBuffer(command_queue, gpu_colormap, CL_TRUE, 0, 256 * sizeof(cl_uint), thermal_colormap, 0, NULL, NULL);

	if (r_code != CL_SUCCESS)
	{
		say("Could not copy the thermal colormap array from the CPU to the GPU.");

		return EXIT_FAILURE;
	}

	// Create an OpenCL program from the kernel source.

	cl_program program = clCreateProgramWithSource(context, 1, (const char**)&kernel_source, (const size_t*)&kernel_source_size, &r_code);

	// Make sure the OpenCL program was created successfully.

	if (r_code != CL_SUCCESS)
	{
		say("Could not create an OpenCL program.");

		return EXIT_FAILURE;
	}

	// Build the OpenCL program.

	r_code = clBuildProgram(program, 1, &device_id, NULL, NULL, NULL);

	// Make sure the OpenCL program was built successfully.

	if (r_code != CL_SUCCESS)
	{
		say("Could not build an OpenCL program.");

		return EXIT_FAILURE;
	}

	// Create the OpenCL kernel from the function "n_body_render" within the
	// OpenCL program.

	cl_kernel kernel = clCreateKernel(program, "n_body_render", &r_code);

	// Make sure the OpenCL kernel was created successfully.

	if (r_code != CL_SUCCESS)
	{
		say("Could not create an OpenCL kernel.");

		return EXIT_FAILURE;
	}

	// Set the n parameter of the OpenCL kernel.

	clSetKernelArg(kernel, 1, sizeof(cl_int), &n);

	// Set the res parameter of the OpenCL kernel.

	clSetKernelArg(kernel, 2, sizeof(cl_int), &res);

	// Set the state parameter of the OpenCL kernel.

	clSetKernelArg(kernel, 3, sizeof(cl_mem), (void*)&gpu_bodies);

	// Set the output parameter of the OpenCL kernel.

	clSetKernelArg(kernel, 4, sizeof(cl_mem), (void*)&gpu_img);

	// Set the thermal_colormap parameter of the OpenCL kernel.

	clSetKernelArg(kernel, 5, sizeof(cl_mem), (void*)&gpu_colormap);

	// PARAM: local_work_size should be modified depending on your GPU. This
	// should be tested on a realtime renderer first, such as
	// CobaltXII/boiler/experimental/n_body_cl/.

	size_t global_work_size = res * res;

	size_t local_work_size = 256;

	// Start the render!

	for (int i = 0; i < frames; i++)
	{
		// Get the starting time.

		clock_t frame_start = clock();

		// Load the current frame.

		std::stringstream name_builder;

		name_builder << "frame_" << i << ".dat";

		std::ifstream frame(name_builder.str());

		frame.read((char*)cpu_bodies, n * sizeof(cl_float4));

		frame.close();

		// Copy the bodies array from the CPU to the GPU.

		r_code = clEnqueueWriteBuffer(command_queue, gpu_bodies, CL_TRUE, 0, n * sizeof(cl_float4), cpu_bodies, 0, NULL, NULL);

		if (r_code != CL_SUCCESS)
		{
			say("Could not copy the body array from the CPU to the GPU.");

			return EXIT_FAILURE;
		}

		// PARAM: The zoom factor.

		float inv_scale = i / 60.0f;

		// Set the inv_scale parameter of the OpenCL kernel.

		clSetKernelArg(kernel, 0, sizeof(cl_float), &inv_scale);

		// Generate the current frame.

		r_code = clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL, &global_work_size, &local_work_size, 0, NULL, NULL);

		if (r_code != CL_SUCCESS)
		{
			say("Could not invoke the render kernel.");

			return EXIT_FAILURE;
		}

		// Read output back into local CPU memory.

		clEnqueueReadBuffer(command_queue, gpu_img, CL_TRUE, 0, res * res * sizeof(cl_uint), cpu_img, 0, NULL, NULL);

		// Save the image.

		std::stringstream out_name_builder;

		out_name_builder << "render_" << i << ".png";

		stbi_write_png(out_name_builder.str().c_str(), res, res, 4, cpu_img, stride_in_bytes);

		// Get the ending time.

		clock_t frame_end = clock();

		// Print the frame elapsed time.

		std::cout << "Frame " << i << " rendered in " << float(frame_end - frame_start) / float(CLOCKS_PER_SEC) << " s" << std::endl;
	}

	return EXIT_SUCCESS;
}